pickup the knife
(lambda $0:de (and:<t*,t> (pickup:<de,t> $0) (?actor:<de,<act,t>> $0 self:act) (?interactor:<de,<intact,t>> $0 brad:intact)(?objref:<de,<obj,t>> $0 knife:obj)))

//de is a davisonian event, act is an actor type, intact is an interactor type, obj is an obj type, ?actor is an actual predicate
//?interactor is an actual predicate as well



//adverbs (ie. modifiers of davidsonian events, not verbs)
pickup the knife quickly
(lambda $0:de (and:<t*,t> (pickup:<de,t> $0) (?actor:<de,<act,t>> $0 self:act) (?interactor:<de,<intact,t>> $0 brad:intact)(?objref:<de,<obj,t>> $0 knife:obj) (how:<de,<adv,t>> $0 quickly:adv)))

//?what abt activated ontological types in the simply typed lambda calculus


this is a knife
[instanceOf(VAR0,knife), this(VAR0)] . [TierAssignment(VAR0,ACTIVATED)]
[instanceOf(VAR0,VAR1), this(VAR0), knife(VAR1)] . [TierAssignment(VAR0,ACTIVATED), TierAssignment(VAR1,INDEFINITE)]
(instanceOf:<obj,<objref,t>> knife:obj this:objref)
(instanceOf:<objactive,<objrefindefinite,t>> knife:objactive this:objrefindefinite)
(instanceOf:<obj,<objref,t> (knife:<ghtier,obj> activated:ghtier) (this:<ghtier,objref> indefinite:ghtier))


this is the knife
(instanceOf:<obj,<objref,t> (knife:<ghtier,obj> activated:ghtier) (this:<ghtier,objref> definite:ghtier))



//giveness hierarchy in parser?
this is the knife


//can "the knife" have a lexical entry in our dictionary?


//doesnt make sense for ghtiers to be learned in thsi lexicon. \
//post process this data, or add rule to the parser / genlex




//seed lexicon
the :- N/N : (lambda $0:<e,t> $0)
the :- NP/NP : (lambda $0:e $0)
the :- NP/N : (lambda $0:<e,t> (the:<<e,t>,e> $0))
//pickup :- S/NP : (lambda $0:obj (pickup:<obj,t> $0))
pickup :- S/NP : (lambda $0:obj (pickup:<obj,t> $0))

pickup :-  :

instanceOf:<<ghtier,obj>,<<ghtier,objref>,t>>
this is a box
(instanceOf:<<ghtier,obj>,<<ghtier,objref>,t>> box:<ghtier,obj> activated:ghtier) (this:<ghtier,objref> indefinite:ghtier))

this is x
(intersect:<ps,<ps,t>> you:ps x:ps)
intersect:<ps,<ps,t>> // Return true:t iff the intersection of the two sets is not empty, approximates containment
this :- S/N : (lambda $0:<e,t> (intersect:<ps,<ps,t>> you:ps (a:<<e,t>,e> $0)))
is :- S\NP/NP : (lambda $0:e (lambda $1:e (eq:<e,<e,t>> $1 $0)))
is :- S\NP/NP : (lambda $0:e (lambda $1:e (intersect:<ps,<ps,t>> $1 $0)))
this :- NP : you:ps
x :- NP : x:ps
you :- NP : you:ps


this is a knife
(instanceOf:<obj,<objref,t>> (knife:<ghtier,obj> activated:ghtier) (this:<ghtier,objref> indefinite:ghtier))

this is the knife
(instanceOf:<obj,<objref,t>> (box:<ghtier,obj> activated:ghtier) (this:<ghtier,objref> definite:ghtier))


pass the knife
(lambda $0:de (and:<t*,t> (pass:<de,t> $0) (?act:<de,<?Actor,t>> $0 self:?Actor) (?interact:<de,<?Interactor,t>> $0 brad:?Interactor)(?Objectreferent:<de,<obj,t>> $0 knife:obj)))

pass the knife quickly
(lambda $0:de (and:<t*,t> (pass:<de,t> $0) (?act:<de,<?Actor,t>> $0 self:?Actor) (?interact:<de,<?Interactor,t>> $0 brad:?Interactor)(?Objectreferent:<de,<obj,t>> $0 knife:obj) (how:<de,<adv,t>> $0 quickly:adv)))

pass the box
(lambda $0:de (and:<t*,t> (pass:<de,t> $0) (?act:<de,<?Actor,t>> $0 self:?Actor) (?interact:<de,<?Interactor,t>> $0 brad:?Interactor)(?Objectreferent:<de,<obj,t>> $0 box:obj)))

pickup :- S/NP : (lambda $0:de (and:<t*,t> (pickup:<de,t> $0) (?act:<de,<?Actor,t>> $0 self:?Actor) (?interact:<de,<?Interactor,t>> $0 brad:?Interactor)))
pickup :- S/NP : (lambda $0:obj (lambda $1:de (and:<t*,t> (pickup:<de,t> $1) (?act:<de,<?Actor,t>> $1 self:?Actor) (?interact:<de,<?Interactor,t>> $1 brad:?Interactor) (?Objectreferent:ref $0)))


pass :- S/NP : (lambda $1:<obj,ref> (lambda $0:de (and:<t*,t> (pass:<de,t> $0) (?act:<de,<?Actor,t>> $0 self:?Actor) (?interact:<de,<?Interactor,t>> $0 brad:?Interactor)(?Objectreferent:<de,<obj,t>> $0 $1))))

we need:
the knife
the red knife
pass the knife
pass the knife quickly
pass the red knife
pass the red knife quickly
pass me the knife
robot, pass me the knife
